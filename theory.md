reconcilation - это алгоритм, за которым стоит то что мы привыкли называть
VDOM

Из нод создается дерево реакт-элементов с помощью совокупности методов рендера. 
Это дерево называется current tree
Дальше это дерево попадает в rendering environment где оно
превращается в набор операций с DOM притом отсортированным в порядке важности.

При первой инициализации среда рендеринга отрисовывает полностью дерево.
и пользователь может увидеть ui.

Нажатие на кнопку --> провоцирует изменение в дереве
и образуется work-in-progress tree.

Далее идет сравнение
И только та часть дерева которая отличается вновь попадет в среду рендеринга и
превратится в набор операций с DOM и отрисуется.

А work in progress tree становится current tree
Особенности: 
1) разработчики реакта разделили механизм сравнения деревьев и среду рендеринга, для того чтобы
React DOM и React Native могли использовать свои среды rendering при использовании одного механизма сравнения.
Механизм сравнения находится в react-core
2) сложный алгоритм имеет O(n3) где n - это количество компонентов, а результат это количество сравнений.
Эта цифра оказалась слишком большой, поэтому выбрали эвристический порядка O(n).
Эвристический - это по сути решение в лоб, но являющее еся достаточным если не требуется предельная точность и могут быть допущения. 
Какие же допущения сделала реакт команда: 
 - элементы с разными типами произведут разные деревья
 - разработчик может указать какие дочерние элементы могут оставаться стабильными
между рендерами с помощью свойства key 

На практике эти предположения верны почти для всех случаев

Вот пример
```
<div>
<Counter/>
</div>

<span>
<Counter/>
</span>
```
При изменении типа элемента с div на span все дерево компонентов содержавшееся в 
div размонтируется и заново отрендерится все дерово со span - хотя и там и там компонент был один.

Практическй пример
```
const ExampleFirst = () => {
    if (this.props.editorMode) {
        return (
            <div className={styles.Container}>
                <div className={styles.image}>
                    <Image />
                    <DeleteUploadControls/>
                </div>
            </div>
        );
    }
    return (
        <div className={styles.Container}>
                <Image />
        </div>
    );
};
```
убираем ```<div className={styles.image}>``` и компонент Image не размонтируется и зново вмонтируется
при переключении на/с режима редактирования.

если Вы поменяете местами 
```
<Image />
<DeleteUploadControls/>
```
то тогда все равно компонент Image будет размонтироваться и 
вмонтироваться 
но поставь тернарку на DeleteUploadControls и будет тебе счастье. 

И именно в реакт 16 вмержился проект react Fiber (он писался два года до этого)
и именно в нем обпределяются приотритеты DOM операций.
_____
*Key*

Напомним вот это "разработчик может указать какие дочерние элементы 
могут оставаться стабильными
между рендерами с помощью свойства key "

И это приводит к следующей ситуации 
Если key поменялся то тогда реакт возьмет размонтирует компонент 
с уже несуществующим key.
Если key не поменялся, но поменялись какие то пропсы то будет 
componentupdated.

Из этого можно сделать вывод если вы делаете список элементов 
и каждому элементу ставите 
в key индекс массива и при этом меняете этот список: меняете местами элементы, удаляйте элементы - то тогда
у Вашего приложения будет меньшая производительность чем она была
бы при сценари где вы в key поставили уникальный id.

_______
Являются ли зуки более медленными из-за создания функций при каждом рендере?

Нет. 
1) Сырая производительность браузера для замыканий не сильно отличается от классов.
2) В классе были большие затраты - созданиеэкземпляра, связывание оработчиков в конструкторе
3) Проект на хуках имеет менее вложенное дерево

____

componentDidMount
componentDidUpdate
componentWillUnmount

useEffect

Задача

В 
```
componentDidMount() {
sleep();
this.setState(this.___ref__.width);
}
```
Сначала лоадинг страницы три секунды и потом только квадрат с написанной в нем шириной

```
useEffect(() => {
sleep();
this.setState(this.___ref__.width);
}, []);
```
Сразу отрисуется страница и квадрат с нулем, потом спустя три секунды нарисуется в квадрате 220

UseEffect не блокирует отрисовку на странице в отличие от componentDidMount.

Кто выполняется в такую же очередь как и componentDidMount - это useEffectLayout

VDOM сформировался --> componentDidMount ---> VDOM переделалось из-за нашего внутреннего кода --> отрисовка в браузере
VDOM сформировался -->  отрисовка в браузере ---> UseEffect --> VDOM переделалось из-за нашего внутреннего кода ---> отрисовка в браузере
VDOM сформировался --> UseLayoutEffect ---> если поместили вUseLayoutEffect код переделавывающий VDOM значит он переделываетсчя сейчас ---> отрисовка в браузере
_____

useEvent - это хук который предложил Ден абрамов 5 мая 2022 в ПР. 



